<?php
/**
 * This class extends the DatabaseConnection class to support connections to a PostgreSQL database.
 * This class may also implement PostgreSQL-specific features.
 * 
 * @version 	$Id: PostgreSqlConnection.php 1547 2008-09-03 05:39:28Z anders $
 */
class PostgreSqlConnection extends DatabaseConnection {
	private $host;
	private $username;
	private $password;
	private $database;
	private $persistent;

	/**
	 * Creates a new instance of this class.
	 * 
	 * If the optional <code>$lazy</code> parameter is set to <code>FALSE</code>, a connection to
	 * the database is established. The default is <code>TRUE</code>, in which case a connection
	 * will be established on the first call to <code>execute()</code> or <code>query()</code>.
	 *
	 * @param bool $lazy	<code>TRUE</code> to hold off establishing a connection to the database
	 * 						(default), <code>FALSE</code> to connect immediately.
	 * @return DatabaseConnection
	 */
	public function __construct ($conf) {
		$this->host       = $conf['host'];
		$this->username   = $conf['username'];
		$this->password   = $conf['password'];
		$this->database   = $conf['database'];
		$this->persistent = isset($conf['persistent']) ? $conf['persistent'] : false;
	}

	/**
	 * Connects to the PostgreSQL database described in this object. If any error occurs, a user
	 * error is triggered.
	 * 
	 * @return bool	<code>TRUE</code> if a connection was successfully established,
	 * 				<code>FALSE</code> if not.
	 */
	public function connect () {
		$connectionString = "host={$this->host} dbname={$this->database} user={$this->username} "
				. "password={$this->password}";
		$this->connection = $this->persistent ? pg_pconnect($connectionString) : pg_connect($connectionString);

		if (!$this->connection) {
			throw new Exception('Could not connect to database!');
		}
		return true;
	}

	/**
	 * Begins a new transaction.
	 */
	public function begin () {
		if (pg_transaction_status($this->connection) !== PGSQL_TRANSACTION_INERROR) {
			pg_query($this->connection, 'BEGIN');
		}
	}

	/**
	 * Commits or rolls back the active transaction, if any. The transaction is rolled back if in an
	 * invalid state, else it is commited.
	 *
	 * @return bool <code>TRUE</code> if transaction was commited, <code>FALSE</code> if rolled back.
	 */
	public function commit () {
		$status = pg_transaction_status($this->connection);
		if ($status === PGSQL_TRANSACTION_UNKNOWN || $status === PGSQL_TRANSACTION_IDLE) return;

		if ($status === PGSQL_TRANSACTION_INERROR) {
			pg_query($this->connection, 'ROLLBACK');
			return false;
		}

		pg_query($this->connection, 'COMMIT');
		return true;
	}

	/**
	 * Rolls back the active transaction.
	 */
	public function rollback () {
		pg_query($this->connection, 'ROLLBACK');
	}

	// query == select? execute == insert/update/del?
	public function query ($query, $params = null) {
		if (!$this->connection) {
			$this->connect();
		}

		$status = pg_transaction_status($this->connection);
		if ($status === PGSQL_TRANSACTION_UNKNOWN || $status === PGSQL_TRANSACTION_INERROR) {
			return false;
		}
		else if ($status === PGSQL_TRANSACTION_IDLE) {
			$this->begin();
		}

		// Interpolate any parameters into query
		$preparedQuery = $this->prepareQuery($query, $params);

		if (pg_send_query($this->connection, $preparedQuery)) {
			$resultResource = pg_get_result($this->connection);
			$resultStatus = pg_result_status($resultResource);
			if ($resultStatus !== PGSQL_FATAL_ERROR) {
				$this->resultSet = new PostgreSqlResultSet($resultResource);
				return $this->resultSet;
			}
			// TODO: Implement custom exception
			throw new Exception(pg_result_error($resultResource),
				(int) pg_result_error_field($resultResource, PGSQL_DIAG_SQLSTATE));
		}

		return false;
	}

	/**
	 * Returns the value of the last sequence in the row created by the last INSERT.
	 *
	 * @return int	The value of the new ID generated by a sequence.
	 */
	public function lastInsertId () {
		return $this->getOne("SELECT LASTVAL()");
	}

	/**
	 * Escapes a value to make it safe for use in SQL queries.
	 * 
	 * Converts null to SQL NULL string, boolean values to accepted string representations, and
	 * escapes necessary characters in strings. Pure numeric values are simply returned as is.
	 *
	 * @param mixed $value	Data value to escape.
	 * @return string	A safe data value for use in SQL queries.
	 */
	protected function escapeValue ($value) {
		if ($value === NULL) {
			return 'NULL';
		}
		if (is_bool($value)) {
			return ($value ? 'true' : 'false');
		}
		if ($this->isPureNumber($value)) {
			return $value;
		}

		if (get_magic_quotes_gpc()) {
			$value = stripslashes($value);
		}
		return "'" . pg_escape_string($value) . "'";
	}

	/**
	 * Stricter type check on numbers. Solves one specific problem where the string value contains
	 * prefixing zeroes, which most likely means it shouldn't be treated as a number but a string of
	 * digits. Ie. telephone numbers, hexadecimal strings, postal codes etc.
	 */
	private function isPureNumber ($value) {
		// Only values considered numeric by PHP are pure numbers
		if (!is_numeric($value)) {
			return false;
		}
		
		// If the value is an actual int or float type variable it's a pure number
		if (is_int($value) || is_float($value)) {
			return true;
		}
		
		// If it contains a decimal point, it's considered a pure number
		if (strpos($value, '.') !== false) {
			return true;
		}
		
		// If an integer cast does not change the number length, it's considered pure (ie. no leading zeroes)
		if (strlen((int) $value) == strlen($value)) {
			return true;
		}
		
		return false;
	}
}
?>
