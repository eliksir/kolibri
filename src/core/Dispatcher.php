<?php
require(ROOT . '/core/InterceptorFactory.php');

/**
 * This class dispatches the request to the interceptors and action target of the request.
 *
 * When an instance of this class is created, the interceptors mapped to intercept the action
 * specified is instantiated along with the action itself. When the <code>invoke()</code> method
 * is called, the interceptors are called in FIFO order (the first defined is the first
 * called). After all interceptors have been processed, the action is invoked.
 *
 * @version		$Id: Dispatcher.php 1516 2008-06-30 17:41:53Z anders $
 */
class Dispatcher {
	/**
	 * Request being processed.
	 * @var Request
	 */
	private $request;

	/**
	 * Stack of interceptors to invoke.
	 * @var array
	 */
	private $stack;

	/**
	 * Target action.
	 * @var Action
	 */
	private $action;

	/**
	 * Method to be invoked on target action.
	 * @var string
	 */
	private $actionMethod;

	/**
	 * Creates an instance of this class.
	 *
	 * The interceptors mapped to the target action is created and pushed to the dispatcher stack.
	 *
	 * @param Request $request				Request object.
	 * @param ActionMapping $actionMapping	Mapping to the action to invoke.
	 * @return Dispatcher
	 */
	public function __construct ($request, $actionMapping) {
		$this->request		= $request;
		$this->actionMethod	= $actionMapping->getActionMethod();
		$mappings			= Config::getInterceptorMappings();
		$stack				= array(); // Holds the interceptors matching our action path

		foreach ($mappings as $uri => $interceptors) {
			// Prepare the mapping as a regex (replaces star wildcard mappings with regex equivalent)
			$uriMatch = '#^' . str_replace('*', '.*?', $uri) . '$#';

			if (preg_match($uriMatch, $request->getUri()) == 1) {
				/*
				 * Current URI matches the mapping. We loop through each interceptor for the
				 * matched URI and add or remove from the final stack depending on it's prefix.
				 */
				foreach ($interceptors as $name => $class) {
					// Only interceptor classes without a ! prefix should be in the stack
					if (substr($class, 0, 1) != '!') {
						$stack[$name] = $class;
					}
					else {
						unset($stack[$name]);
					}
				}
			}
		}

		$class = $actionMapping->getActionClass();
		$this->action = new $class($this->request);
		$this->stack = InterceptorFactory::createInterceptors($stack);
	}

	/**
	 * Invokes the next command in the dispatcher stack.
	 *
	 * @return mixed	A sub-class of <code>BaseResult</code> with the result of the command, or
	 * 					<code>NULL</code> if no result was generated by the command.
	 */
	public function invoke () {
		// Pull the next interceptor off the stack
		$current = array_shift($this->stack);

		// If an interceptor is next we invoke it
		if ($current !== null) {
			$result = $current->intercept($this);
			$current->destroy(); // Let the interceptor clean up
			return $result;
		}

		// Lastly any before-method is invoked before the action itself
		if (method_exists($this->action, 'before')) {
			if (($result = $this->action->before()) !== null) {
				return $result;
			}
		}

		if (is_callable($this->actionMethod)) {
			$fn = $this->actionMethod;
			return $fn($this->getRequest());
		}

		return $this->action->{$this->actionMethod}($this->getRequest());
	}

	public function getRequest () {
		return $this->request;
	}

	public function getAction () {
		return $this->action;
	}
}
?>
